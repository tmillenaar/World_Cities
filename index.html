<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>World city population</title>
    <script src="http://d3js.org/d3.v4.min.js" charset="utf-8"></script>
  </head>
    <body>
    <h1>World city population</h1>
    <script>
        var canvas_height = 700
        var canvas_width = 1200
        var svg = d3.select("body").append("svg")
                    .attr('id','my_svg_canvas')
                    .attr('height', canvas_height)
                    .attr('width', canvas_width)
                    .call(d3.zoom().on("zoom", zoomed).translateExtent([[0, 0], [canvas_width, canvas_height]]).scaleExtent([1, 40]))
                    .append("g")

        var current_projection = 'ST'
        var worldcities=[]
        var cityname=[]
        var minlat = -90
        var maxlat = 90
        var minlon = -180
        var maxlon = 180
              
        data_is_read = false
        grid_is_made = false
        
        addrect(0,0,'100%','100%','black','3px','black') //Create Background
        var tooltip = svg.append('text')
            .text("a simple tooltip")
            .attr('y',70)        //x will be set when made visible upon hover
            .style("visibility", "hidden")
            .style('fill','White')
            .style('stroke','black')
            .style('stroke-width', '0px' )
            .style('font-size', '50px')
            .style("font-family","Times")
            .style('font-style','oblique');
        
        //<text x="20" y="20" font-family="sans-serif" font-size="20px" fill="red">Hello!</text>
        
        function zoomed() {
            //if (d3.select('svg').attr('height')<=800){
            svg.attr("transform", d3.event.transform);//..extent([extent]);
           
        }
        
        var x = d3.scaleLinear()
          .domain([0, canvas_width])
          .range([0, canvas_width]);

        var y = d3.scaleLinear()
            .domain([0, canvas_height])
            .range([0, canvas_height]);
            
       
        
        make_worldpicture('ST') //call for initial 
        
        
        function make_worldpicture(projection){
              //d3.select("my_svg_canvas").selectAll("*").remove();
              
              
              d3.csv("worldcities.csv", function(data) {  
                  /*
                  Data file buidlup:
                  
                  "city","city_ascii","lat","lng","country","iso2","iso3","admin_name","capital","population","id"
                  
                  Only lng, lat and population are pushed to worldcities
                  */
                  if (data_is_read == false){
                      var i = 0
                      data.forEach(function (d){
                        if (parseFloat(d.population) > 1){
                            worldcities.push([parseFloat(d.lng),parseFloat(d.lat),parseFloat(d.population)]);
                            
                            //add pure lat-long plot as initial plot
                            addcirc( 'data', 'citycircle'+i, lon_to_px_boundaries(parseFloat(d.lng),minlon,maxlon) , lat_to_px_boundaries (parseFloat(d.lat),minlat,maxlat) ,1+parseFloat(d.population)/1200000,d3.select("#change_color_dropdown").node().value,0,0,0.25)
                            
                            svg.select("#citycircle"+i)
                                .on('mouseover',function () {
                                  tooltip.text(String(d.city+', '+d.country))
                                  size = tooltip.node().getBBox();
                                  var x = canvas_width/2.-size.width/2.
                                  tooltip.attr('x', x)
                                  tooltip.style("visibility", "visible")
                                })
                                .on('mouseout', function(){
                                  tooltip.style("visibility", "hidden");
                                });
                            
                            i=i+1
                        }
                      });	
                      //console.log(cityname)
                      data_is_read = true
                  }
              });
              if (data_is_read){
                  grid_color = d3.select("#change_grid_color_dropdown").node().value
                  for (var i=0; i < (worldcities.length); i++) {
                  //console.log(worldcities[i][2])
                  
                  if (projection=='ST'){
                       //pure lat-long plot
                       lon = lon_to_px_boundaries(worldcities[i][0],minlon,maxlon)
                       lat = lat_to_px_boundaries(worldcities[i][1],minlat,maxlat)
                       var pop = 1+parseFloat(worldcities[i][2])/1200000
                  }
                  
                  if (projection=='WT'){
                       //Winkel_tripel :
                       lon = lon_to_px_boundaries(Winkel_tripel_x (worldcities[i][0],worldcities[i][1]),minlon,maxlon)
                       lat = lat_to_px_boundaries(Winkel_tripel_y(worldcities[i][0],worldcities[i][1]),minlat,maxlat)
                       var pop = 1+parseFloat(worldcities[i][2])/1200000
                  }
                  
                  if (projection=='KV'){
                       //Kavrayskiy_VII :
                       lon = lon_to_px_boundaries(Kavrayskiy_VII_lon (worldcities[i][0],worldcities[i][1]),minlon,maxlon)
                       lat = lat_to_px_boundaries(worldcities[i][1],minlat,maxlat)
                       var pop = 1.+parseFloat(worldcities[i][2])/1200000.
                  }
                  
                  d3.selectAll("#citycircle"+i) 
                      .attr('fill', d3.select("#change_color_dropdown").node().value)
                      .attr('cx',lon)
                      .attr('cy',lat)
                      .attr('r',pop)
                      
                  /*
                        if (projection=='ST'){
                            //pure lat-long plot
                            addcirc( 'citycircle', lon_to_px(worldcities[i][0]) , lat_to_px (worldcities[i][1]) ,1+worldcities[i][2]/1200000,d3.select("#change_color_dropdown").node().value,0,0,0.25)
                        };
                        
                        if (projection=='WT'){
                            //Winkel_tripel :
                            addcirc( 'citycircle', lon_to_px(Winkel_tripel_x (worldcities[i][0],worldcities[i][1])) , lat_to_px (Winkel_tripel_y(worldcities[i][0],worldcities[i][1])) ,1+worldcities[i][2]/1200000,d3.select("#change_color_dropdown").node().value,0,'none',0.25)
                        };
                        
                        if (projection=='KV'){
                            //Kavrayskiy_VII :
                            addcirc( 'citycircle', lon_to_px(Kavrayskiy_VII_lon (worldcities[i][0],worldcities[i][1])) , lat_to_px (worldcities[i][1]) ,1+worldcities[i][2]/1200000,d3.select("#change_color_dropdown").node().value,0,0,0.25)
                        };
                        
                        */
                  }
              }else{
                  grid_color = 'orange'
              }
              
              
                    
              if (grid_is_made){
                  for (var i=-45; i<=45;i++){
                      for (var j=-45; j<=45;j=j+5){
                          if (projection=='ST'){
                                //pure lat-long grid:
                                great_circ_lon = lon_to_px_boundaries (parseFloat(j*4),minlon,maxlon)
                                great_circ_lat = lat_to_px_boundaries (parseFloat(2*i),minlat,maxlat)
                                small_circ_lon = lon_to_px_boundaries (parseFloat(i*4),minlon,maxlon)
                                small_circ_lat = lat_to_px_boundaries (parseFloat(2*j),minlat,maxlat)
                                eqlon = lon_to_px_boundaries (parseFloat(i*4),minlon,maxlon)
                                eqlat = lat_to_px_boundaries (parseFloat(2*j),minlat,maxlat)
                          };
                            
                          if (projection=='WT'){
                                //Winkel_tripel grid:
                                great_circ_lon = lon_to_px_boundaries(Winkel_tripel_x (j*4,2*i),minlon,maxlon)
                                great_circ_lat = lat_to_px_boundaries(Winkel_tripel_y (j*4,2*i),minlat,maxlat)
                                small_circ_lon = lon_to_px_boundaries(Winkel_tripel_x (i*4,2*j),minlon,maxlon)
                                small_circ_lat = lat_to_px_boundaries(Winkel_tripel_y (i*4,2*j),minlat,maxlat)
                                eqlon = lon_to_px_boundaries(Winkel_tripel_x (i*4,2*j),minlon,maxlon)
                                eqlat = lat_to_px_boundaries(Winkel_tripel_y (i*4,2*j),minlat,maxlat)
                          };
                            
                          if (projection=='KV'){
                                //Kavrayskiy_VII grid:
                                great_circ_lon = lon_to_px_boundaries(Kavrayskiy_VII_lon (j*4,2*i),minlon,maxlon)
                                great_circ_lat = lat_to_px_boundaries(2*i,minlat,maxlat)
                                small_circ_lon = lon_to_px_boundaries(Kavrayskiy_VII_lon (i*4,2*j),minlon,maxlon)
                                small_circ_lat = lat_to_px_boundaries(2*j,minlat,maxlat)
                                eqlon = lon_to_px_boundaries(Kavrayskiy_VII_lon (i*4,2*j),minlon,maxlon)
                                eqlat = lat_to_px_boundaries(2*j,minlat,maxlat)
                          };
                          
                          d3.selectAll("#greatcircle"+i+'-'+j)
                                .attr('fill',d3.select("#change_grid_color_dropdown").node().value)
                                .attr('cx',great_circ_lon)
                                .attr('cy',great_circ_lat)
                                
                          d3.selectAll("#smallcircle"+i+'-'+j)
                                .attr('fill',d3.select("#change_grid_color_dropdown").node().value)
                                .attr('cx',small_circ_lon)
                                .attr('cy',small_circ_lat)
                                
                          d3.selectAll("#equator_circle"+i+'-'+j)
                                .attr('cx',eqlon)
                                .attr('cy',eqlat)
                      }
                  }
              }else{ //create inititial grid
                  for (var i=-45; i<=45;i++){
                      for (var j=-45; j<=45;j=j+5){
                        if (projection=='ST'){
                              //pure lat-long grid:
                              addcirc( 'grid_circle', 'greatcircle'+i+'-'+j, lon_to_px_boundaries(parseFloat(j*4),minlon,maxlon) , lat_to_px_boundaries (parseFloat(2*i),minlat,maxlat) ,1,grid_color,0,0,0.4)
                              addcirc( 'grid_circle', 'smallcircle'+i+'-'+j, lon_to_px_boundaries(parseFloat(i*4),minlon,maxlon) , lat_to_px_boundaries (parseFloat(2*j),minlat,maxlat) ,1,grid_color,0,0,0.4)
                              if (j==0){
                                  addcirc( 'grid_equator', 'equator_circle'+i+'-'+j, lon_to_px_boundaries(parseFloat(i*4),minlon,maxlon) , lat_to_px_boundaries (parseFloat(2*j),minlat,maxlat) ,1,'red',0,0,0.9)
                              };
                        };
                          /*
                        if (projection=='WT'){
                              //Winkel_tripel grid:
                              addcirc( 'grid_circle', 'greatcircle'+i+'-'+j, lon_to_px_boundaries(Winkel_tripel_x (j*4,2*i),minlat,maxlat) , lat_to_px_boundaries(Winkel_tripel_y(j*4,2*i),minlat,maxlat),1,grid_color,0,0,0.4)
                              addcirc( 'grid_circle', 'smallcircle'+i+'-'+j, lon_to_px_boundaries(Winkel_tripel_x (i*4,2*j),minlat,maxlat) , lat_to_px_boundaries(Winkel_tripel_y(i*4,2*j),minlat,maxlat),1,grid_color,0,0,0.4)
                              if (j==0){
                                  addcirc( 'grid_equator', 'equator_circle'+i+','+j, lon_to_px_boundaries(Winkel_tripel_x (i*4,2*j),minlat,maxlat) , lat_to_px_boundaries(Winkel_tripel_y(i*4,2*j),minlat,maxlat),1,'red',0,0,0.90)
                              };
                        };
                          
                        if (projection=='KV'){
                              //Kavrayskiy_VII grid:
                              addcirc( 'grid_circle', 'greatcircle'+i+'-'+j, lon_to_px_boundaries(Kavrayskiy_VII_lon (j*4,2*i),minlat,maxlat) , lat_to_px_boundaries(2*i,minlat,maxlat) ,1,grid_color,0,0,0.4)
                              addcirc( 'grid_circle', 'smallcircle'+i+'-'+j, lon_to_px_boundaries(Kavrayskiy_VII_lon (i*4,2*j),minlat,maxlat) , lat_to_px_boundaries(2*j,minlat,maxlat) ,1,grid_color,0,0,0.4)
                              if (j==0){
                                  addcirc( 'grid_equator', 'equator_circle'+i+','+j, lon_to_px_boundaries(Kavrayskiy_VII_lon (i*4,2*j),minlat,maxlat) , lat_to_px_boundaries(2*j,minlat,maxlat) ,1,'red',0,0,0.9)
                              };
                        };*/
                        grid_is_made = true
                    }
                };
                if (projection=='KV'){
                    addcirc( 'grid_circle', 'smallcircle'+i+'-'+j, lon_to_px_boundaries(Kavrayskiy_VII_lon (i*4,88),minlon,maxlon) , lat_to_px_boundaries(88,minlat,maxlat) ,1,grid_color,0,0,0.4) //plot top horizontal gridline
                    addcirc( 'grid_circle', 'smallcircle'+i+'-'+j, lon_to_px_boundaries(Kavrayskiy_VII_lon (i*4,-88),minlon,maxlon) , lat_to_px_boundaries(-88,minlat,maxlat) ,1,grid_color,0,0,0.4) //plot lowes horizontal gridline
                };
                if (projection=='WT'){
                    addcirc( 'grid_circle', 'smallcircle'+i+'-'+j, lon_to_px_boundaries(Winkel_tripel_x (i*4,88),minlon,maxlon) , lat_to_px_boundaries(Winkel_tripel_y(i*4,88),minlat,maxlat) ,1,grid_color,0,0,0.4) //plot top horizontal gridline
                    addcirc( 'grid_circle', 'smallcircle'+i+'-'+j, lon_to_px_boundaries(Winkel_tripel_x (i*4,-88),minlon,maxlon) , lat_to_px_boundaries(Winkel_tripel_y(-i*4,-88),minlat,maxlat) ,1,grid_color,0,0,0.4) //plot lowes horizontal gridline
                };
              };
        
        };
                
        d3.selection("select").on("change",function(){
            var color = d3.select("#change_color_dropdown").node().value;
            d3.selectAll(".data").attr('fill',color)
            var color = d3.select("#change_grid_color_dropdown").node().value;
            d3.selectAll(".grid_circle").attr('fill',color)
        })
          
        function lon_to_px (lon){
          return ((canvas_width)*(180+parseFloat(lon)))/360.
        }
        
        function lon_to_px_boundaries (lon,lonmin,lonmax){
          return canvas_width*(lon-lonmin)/(lonmax-lonmin)
        }
        
        function lat_to_px (lat){
          return canvas_height-canvas_height*(90+parseFloat(lat))/180
        }
        
        function lat_to_px_boundaries (lon,lonmin,lonmax){
          if (lonmin >= -90 && lonmax <= 90 && lonmin < lonmax){
              return canvas_height-canvas_height*(lon-lonmin)/(lonmax-lonmin)
          }else{
              console.log('error, min or max latitude out of bounds')
              return canvas_height-canvas_height*(lon+90)/(90+90)
          }
        }
        
        function Kavrayskiy_VII_lon (lon,lat){
        lon = lon*3.1415/180
        lat = lat*3.1415/180
        lon = 3*lon/2 * Math.sqrt( (1/3) - (lat/3.1415)**2 )
        return lon = lon*180/3.1415
        };
        
        function Winkel_tripel_x (lon,lat) {
              if (lon==0){lon=0.0001};  // cannot divide by alpha==0
              lon = lon*3.1415/180
              lat = lat*3.1415/180
              parallel = 0.5*Math.acos(2/3.1415)
              alpha = Math.acos( Math.cos(lat)*Math.cos((lon-0)/2) )
              lon = 0.5*( (lon-0)*Math.cos(parallel) + (2*Math.cos(lat)*Math.sin((lon-0)/2) ) / (Math.sin(alpha)/alpha))
              return lon=lon*180/3.1415
        };
        
        function Winkel_tripel_y (lon,lat) {
              if (lon==0){lon=0.0001};  // cannot divide by alpha==0
              lon = lon*3.1415/180
              lat = lat*3.1415/180
              parallel = 0.5*Math.acos(2/3.1415)
              alpha = Math.acos( Math.cos(lat)*Math.cos((lon-0)/2) )
              //return lon = 0.5*( lon*Math.cos(parallel) + (2*Math.cos(lat)*Math. sin(lon/2) ) / (Math.sin(alpha)/alpha))
              lat = 0.5*( lat + Math.sin(lat)/(Math.sin(alpha)/alpha) )
              return lat = lat*180/3.1415
        };
        
        function addrect(x,y,width,height,fill,stroke_width,stroke) {
          var name = svg.append('rect')
              .attr('x', x)
              .attr('y', y)
              .attr('width', width)
              .attr('height', height)
              .attr('fill', fill)
              .attr('stroke-width', stroke_width)
              .attr('stroke', stroke)
              .append("g");
        };
        
        function addcirc(classid,id,x,y,diameter,fill,stroke_width,stroke,alpha) {
          var name = svg.append('circle')
              .attr('class',classid)
              .attr('id',id)
              .attr('cx', x)
              .attr('cy', y)
              .attr('r', diameter)
              .attr('fill', fill)
              .attr('stroke-width', stroke_width)
              .attr('stroke', stroke)
              .attr('fill-opacity', alpha)
              .append("g");
        };
        
        function check_input(projection){
              //event.preventDefault();  //prevent page from refreshing after the 'limit to' submit
              
              minlat = parseFloat(document.getElementById("lon_lat_bound1").value)
              maxlat = parseFloat(document.getElementById("lon_lat_bound2").value)
              minlon = parseFloat(document.getElementById("lon_lat_bound3").value)
              maxlon = parseFloat(document.getElementById("lon_lat_bound4").value)
              
              make_worldpicture(projection)
        };
        
        function new_projection(projection){
            current_projection = projection
            make_worldpicture(projection)
        }
        
        function reset_bounds(projection){
            minlat = -90
            maxlat = 90
            minlon = -180
            maxlon = 180
            make_worldpicture(projection)
        };
        
        function test_bounds(projection){
        
              if     (parseFloat(minlat) < -90) {console.log("Lower latitude bound too low")}
                else if(maxlat > 90 ) {console.log("Upper latitude bound too high")}
                else if(minlat >= maxlat){console.log('Lower latitude limit must be lower then upper limit')}
                else if(minlon < -180) {console.log("Lower longtitude bound too low")}
                else if(maxlon > 180 ) {console.log("Upper longtitude bound too high")}
                else if(minlon >= maxlon){console.log('Lower longtitude limit must be lower then upper limit')}
                else {make_worldpicture(current_projection)
              };
              console.log(projection)
              make_worldpicture(projection)
        };
    
    </script>
    
    <br>
    <p> 
    <input type="button" value="No projection" onclick="new_projection('ST')"/>&nbsp&nbsp&nbsp
    <input type="button" value="Kavrayskiy VII projection" onclick="new_projection('KV')"/>&nbsp&nbsp&nbsp
    <input type="button" value="Winkel Tripel projection" onclick="new_projection('WT')"/>&nbsp&nbsp&nbsp <br><br>
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data Color:   
        <select id="change_color_dropdown">
            <option value="chocolate">chocolate</option>
            <option value="white">white</option>
            <option value="cyan">cyan</option>
            <option value="green">green</option>
        </select>
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Grid Color:   
        <select id="change_grid_color_dropdown">
            <option value="orange">orange</option>
            <option value="white">white</option>
            <option value="hotpink">Pink</option>
        </select>
        
        <br>
    
        <form id="lon_lat_bounds">
            Lower bound latitude:   <input type="text" id="lon_lat_bound1"><br>
            Upper bound latitude:   <input type="text" id="lon_lat_bound2"><br>
            Lower bound longtitude: <input type="text" id="lon_lat_bound3"><br>
            Upper bound longtitude: <input type="text" id="lon_lat_bound4"><br>
            <input type="button" value="Limit to" onclick="check_input(current_projection)"/>&nbsp&nbsp&nbsp
            <input type="button" value="Reset bounds" onclick="reset_bounds(current_projection)"/>&nbsp&nbsp&nbsp<br><br>
        </form>     
    </p>
    
    <p>Data obtained from https://simplemaps.com/data/world-cities</p>
    
  </body>
</html>